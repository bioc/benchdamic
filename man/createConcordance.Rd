% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotConcordance.R
\name{createConcordance}
\alias{createConcordance}
\title{createConcordance}
\usage{
createConcordance(object, slot = "pValMat", colName = "rawP", type = "pvalue")
}
\arguments{
\item{object}{Output of the differential abundance tests on the comparisons
of Subset1 and Subset2. Must follow a specific structure list with subset,
comparison, and method levels. For each method, \code{pValMat},
\code{statInfo} matrices and method's \code{name} must be present (See
vignette for detailed information).}

\item{slot}{A character vector with 1 or number-of-methods-times repeats of
the slot names where to extract values for each method (default = "pValMat").}

\item{colName}{A character vector with 1 or number-of-methods-times repeats
of the column name of the slot where to extract values for each method
(default = "rawP").}

\item{type}{A character vector with 1 or number-of-methods-times repeats
of the value type of the column selected where to extract values for each
method. Two values are possible: "pvalue" or "logfc" (default = "pvalue").}
}
\value{
A long format \code{data.frame} object with several columns:
\itemize{
    \item{\code{comparison}}{ which indicates the comparison number;}
    \item{\code{n_features }}{ which indicates the total number of taxa in
    the comparison dataset;}
    \item{\code{method1}}{ which contains the first method name;}
    \item{\code{method2}}{ which contains the first method name;}
    \item{\code{rank}}{;}
    \item{\code{concordance}}{ which is defined as the cardinality of the
    intersection of the top rank elements of each list, divided by rank, i.e.
    , \eqn{(L_{1:rank} \bigcap M_{1:rank})/(rank)}, where L and M represent
    the lists of the extracted statistics of method1 and method2
    respectively (averaged values between subset1 and subset2).}}
}
\description{
Compute the between and within method concordances comparing the lists of
extracted statistics from the outputs of the differential abundance detection
methods.
}
\examples{
data("ps_plaque_16S")

set.seed(123)
phyloseq::sample_data(ps_plaque_16S)$HMP_BODY_SUBSITE <- factor(
    phyloseq::sample_data(ps_plaque_16S)$HMP_BODY_SUBSITE)
# At least N = 100 is suggested
split_list <- createSplits(object = ps_plaque_16S, varName =
    "HMP_BODY_SUBSITE", paired = "RSID", balanced = TRUE, N = 10)
# Run some methods
# lapply -> Subset1 and Subset2
Plaque_16S_splitsDA <- lapply(X = split_list, FUN = function(subset){
    # apply -> Comparison1, Comparison2, ..., Comparison10
    apply(X = subset, MARGIN = 1, FUN = function(splits) {
        # Splitting
        ps <- phyloseq::prune_samples(phyloseq::sample_names(ps_plaque_16S)
            \%in\% splits, ps_plaque_16S)
        # Keep only present taxa
        ps <- phyloseq::filter_taxa(ps, function(x) sum(x>0)>0, 1)
        # Adding scaling and normalization factors
        ps <- norm_edgeR(object = ps, method = "TMM")
        ps <- norm_CSS(object = ps, method = "median")
        # DA analysis
        returnList = list()
        returnList = within(returnList, {
            da.limma <- DA_limma(object = ps, design = ~ 1 +
                HMP_BODY_SUBSITE, coef = 2, norm = "TMM")
            da.limma.css <- DA_limma(object = ps, design = ~ 1 +
                HMP_BODY_SUBSITE, coef = 2, norm = "CSSmedian")
        })
        return(returnList)
    })
})

# Concordance for p-values
concordance_pvalues = createConcordance(object = Plaque_16S_splitsDA, slot =
    "pValMat", colName = "rawP", type = "pvalue")
# Concordance for log fold changes
concordance_logfc = createConcordance(object = Plaque_16S_splitsDA, slot =
    "statInfo", colName = "logFC", type = "logfc")
# Concordance for log fold changes in the first method and p-values in the
# other
concordance_logfc_pvalues = createConcordance(object = Plaque_16S_splitsDA,
    slot = c("statInfo", "pValMat"), colName = c("logFC", "rawP"), type =
    c("logfc","pvalue"))
}
\seealso{
[benchdamic::extractStatistics()] and [benchdamic::areaCAT()].
}
